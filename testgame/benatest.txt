global variable, begin
	1, attack to test
	2, attack data
end

#for integration with autotest.rpg
define constant(11, assert expression string)
script, assert failure, begin
  $1="ASSERT FAILURE:"
  trace(1)
  trace(assert expression string)
  show textbox (42) #containing "${S11}"
end

plotscript, attackdatatestscript, begin
	variable (data, prompt, sl, runall, choice)

	$0="Enter Attack Number: "
	prompt := create text
	set horiz anchor (prompt, edge:middle)
	set slice text (prompt, 0), clear string (0)
	put slice (prompt, 100, 80)
	clamp slice (prompt, lookup slice (sl:root))
	input string (0)
	attack to test := number from string (0), clear string (0)
	sl := create sprite (spritetype:attack, get attack data (attack to test, attack:picture))
	
	$0="Enter to run through all. \nType a number to check a constant."
	set slice text (prompt, 0), clear string (0)
	clamp slice (prompt, lookup slice (sl:root))
	input string (0)
	choice := number from string (0), clear string (0)
	if (choice == 0) then (runall := true, attack data := 1)
	else (
		attack data := number from string (0), clear string (0)
	)

	while (true) do (
		mainloop
	)
	
	subscript, mainloop, begin
		check new data
		wait
	end
	
	subscript, check new data, begin
		data := get attack data (attack to test, attack data)
		
		# default text
		clear string (0)
		$0="Undefined Constant (skip to 70): "
		append number (0, attack data)
		set slice text (prompt, 0)
		clamp slice (prompt, lookup slice (sl:root))
		clear string (0)
		
		switch (attack data) do (
			case (attack:picture) $0="picture: "
			case (attack:target stat) $0="target stat: "
			case (attack:palette) $0="palette: "
			case (attack:weapon picture) $0="weapon picture: "
			case (attack:weapon palette) $0="weapon palette: "
			case (attack:anim pattern) $0="anim pattern: "
			case (attack:target class) $0="target class: "
			case (attack:target set) $0="target set: "
			case (attack:damage math) $0="damage math: "
			case (attack:aim math) $0="aim math: "
			case (attack:base attack) $0="base attack: "
			case (attack:base defense) $0="base defense: "
			case (attack:mp cost) $0="mp cost: "
			case (attack:hp cost) $0="hp cost: "
			case (attack:money cost) $0="money cost: "
			case (attack:extra damage) $0="extra damage: "
			case (attack:attacker anim) $0="attacker anim: "
			case (attack:delay) $0="delay: "
			case (attack:turn delay) $0="turn delay: "
			case (attack:hits) $0="hits: "
			case (attack:prefer target) $0="prefer target: "
			case (attack:prefer target stat) $0="prefer target stat: "
			case (attack:dramatic pause) $0="dramatic pause: "
			case (attack:caption time) $0="caption time: "
			case (attack:caption delay) $0="caption delay: "
			case (attack:sound effect) $0="sound effect: "
			case (attack:learn sound effect) $0="learn sound effect: "
			case (attack:base accuracy) $0="base accuracy: "
			case (attack:base dodge) $0="base dodge: "
			case (attack:randomization) $0="randomization: "
			case (attack:damage color) $0="damage color: "
			case (attack:target offset x) $0="target offset x: "
			case (attack:target offset y) $0="target offset y: "
			case (attack:target align h) $0="target align h: "
			case (attack:target align v) $0="target align v: "
			case (attack:change control) $0="change control: "
			case (attack:change turncoat) $0="change turncoat: "
			case (attack:change defector) $0="change defector: "
			# Attack Data Bitsets
			case (attack:cure) $0="cure: "
			case (attack:divide spread) $0="divide spread: "
			case (attack:absorb) $0="absorb: "
			case (attack:unreversible picture) $0="unreversible picture: "
			case (attack:can steal item) $0="can steal item: "
			# case (attack:elemental damage) $0="elemental damage: "
			# case (attack:cannot target enemy slot) $0="cannot target enemy slot: "
			# case (attack:cannot target hero slot) $0="cannot target hero slot: "
			case (attack:ignore extra hits) $0="ignore extra hits: "
			case (attack:erase rewards) $0="erase rewards: "
			case (attack:show damage without inflicting) $0="show damage without inflicting: "
			case (attack:store target) $0="store target: "
			case (attack:delete stored targets) $0="delete stored targets: "
			case (attack:auto target) $0="auto target: "
			case (attack:show name) $0="show name: "
			case (attack:dont display damage) $0="dont display damage: "
			case (attack:dont display miss) $0="dont display miss: "
			case (attack:dont display fail) $0="dont display fail: "
			case (attack:reset target stat) $0="reset target stat: "
			case (attack:allow excess cure) $0="allow excess cure: "
			case (attack:useable outside battle) $0="useable outside battle: "
			case (attack:useable inside battle) $0="useable inside battle: "
			case (attack:damage can be zero) $0="damage can be zero: "
			case (attack:force run) $0="force run: "
			case (attack:force victory) $0="force victory: "
			case (attack:force battle exit) $0="force battle exit: "
			case (attack:mutable) $0="mutable: "
			case (attack:fail if target poison) $0="fail if target poison: "
			case (attack:fail if target stun) $0="fail if target stun: "
			case (attack:fail if target mute) $0="fail if target mute: "
			case (attack:percent damage not set) $0="percent damage not set: "
			case (attack:no chain on fail) $0="no chain on fail: "
			case (attack:reset poison) $0="reset poison: "
			case (attack:reset regen) $0="reset regen: "
			case (attack:reset stun) $0="reset stun: "
			case (attack:reset mute) $0="reset mute: "
			case (attack:cancel targets attack) $0="cancel targets attack: "
			case (attack:no cancel by attacks) $0="no cancel by attacks: "
			case (attack:no spawn on attack) $0="no spawn on attack: "
			case (attack:no spawn on kill) $0="no spawn on kill: "
			case (attack:check costs as item) $0="check costs as item: "
			case (attack:recheck costs after delay) $0="recheck costs after delay: "
			case (attack:target no flinch) $0="target no flinch: "
			case (attack:no exceed target stat) $0="no exceed target stat: "
			case (attack:non blocking) $0="non blocking: "
			case (attack:no trigger elemental counters) $0="no trigger elemental counters: "
			case (attack:poison is negative regen) $0="poison is negative regen: "
			case (attack:always hide attacker) $0="always hide attacker: "
			case (attack:always unhide attacker) $0="always unhide attacker: "
			case (attack:blocking counterattack) $0="blocking counterattack: "
			case (attack:enemy target readymeter) $0="enemy target readymeter: "
			case (attack:fill target readymeter) $0="fill target readymeter: "
			case (attack:fail if target regen) $0="fail if target regen: "
		)
		
		if (string length (0)) then (
			append number (0, data)
			set slice text (prompt, 0)
			clamp slice (prompt, lookup slice (sl:root))
		)
		
		wait for key (any key)
		if (runall == True) then (attack data += 1) else (exit script)
	end
end